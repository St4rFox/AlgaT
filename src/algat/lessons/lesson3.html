<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lesson 3</title>
</head>
<body style="margin-right: 10px;">
<h1 align="center"><font size="20">Metodi di scansione</font></h1>
<b1><font size="6">
    I <b>Metodi di Scansione</b> che andremo ad analizzare sono i più conosciuti, <i>H(K,i)</i> rappresenta la posizione
    della chiave <i>K</i> dopo <i>i</i> ispezioni fallite.<br>
    Ovviamente la funzione <i>H(K,i)</i> va scelta in modo che si tocchino tutte le posizioni <i>m</i> del vettore <i>A</i> una e
    una sola volta, così, se il vettore <i>A</i> è completamente occupato e la chiave <i>K</i> non vi è contenuta, la ricerca
    si può arrestare non appena verrà toccata per la seconda volta la posizione di partenza <i>H(K)</i>
    <br>

    <h2 align="center"><font size="8">Scansione Lineare</font></h2>
    <h5 align="center">H(K,i) = (H(K)+ h*i) % m</h5><br>

    Uno dei problemi principali di questo metodo è che il primo elemento determina l'intera sequenza.<br>
    Questa scansione ci permette di avere m sequenza distinte, ma contemporaneamente comporta l'insorgere
    di Agglomerazione Primaria, cioè la formazione di lunghe catene di
    celle occupate seguite da ampie sezioni vuote, generando così un aumento nei tempi
    medi delle operazioni di inserimento e cancellazione.

    <h2 align="center"><font size="8">Scansione Quadratica</font></h2>
    <h5 align="center">H(K,i) = (H(K) + h*i^2) mod m</h5>

    L'ispezione inizia in <i>H(K)</i> e prosegue quadraticamente in base al Passo di Scansione <i>i</i>;<br>
    Allo stesso modo della Scansione Lineare, questo metodo ci consente di creare <i>m</i> sequenze distinte, ma sfortunatamente
    non restituisce una permutazione e assegna la medesima sequenza a chiavi
    con la stessa ispezione iniziale andando a creare un errore di Agglomerazione Secondaria.

    <h2 align="center"><font size="8">Scansione Pseudo-Casuale</font></h2>
    <h5 align="center">H(K,i)=(H(K)+r) mod m</h5>

    Partendo dal valore <i>H(K)</i> si scorre successivamente sulla base del valore r che rappresenta un numero casuale compreso tra 0 e <i>m-1</i>;<br>
    In questo modo sono possibili m sequenze distinte, ottenendo in questo caso come sequenza risultante una
    permutazione.<br>
    Permane il problema di Agglomerazione Secondaria.

    <h2 align="center"><font size="8">Scansione con Doppio Hashing</font></h2>
    <h5 align="center">H(K,i)=(H(K)+ i * H'(K)) mod m</h5>

    L'utilizzo contemporaneo di due funzioni hash (una di base e l'altra ausiliaria, destinata a calcolare l'offset)
    permettono di generare m^2 sequenze di ispezione distinte.<br>
    Al fine di garantire una permutazione quanto più completa possibile,<br> <i>H'(K)</i>
    ed m devono essere primi tra loro.
</font>

    <h1 align="center"><font size="20">Cancellazione</font></h1>
<b1><font size="6">
    Un ulteriore problema nel caso di utilizzo di una tabella a Indirizzamento Aperto è rappresentato dalla
    cancellazione di un valore, infatti sostituendo la chiave da cancellare con un nil andremmo a creare un problema legato
    alla scansione della tabella.<br>
    Infatti, nel caso di una ricerca di una chiave con sequenza passante per la locazione appartenente precedentemente alla
    chiave cancellata, la funzione di scansione andrebbe a bloccarsi in questa posizione facendo credere all'utente che la
    chiave ricercata non è presente nella tabella.<br>
    Al fine di risolvere questo problema viene adottato un valore <i>Deleted</i>, in modo che risulti una posizione vuota durante
    l'operazione di inserimento e, invece, risulti una posizione occupata durante l'operazione di ricerca.
</font>
</b1>
</b1>
</body>
</html>